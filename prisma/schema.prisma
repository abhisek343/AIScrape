generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Workflow {
  id          String  @id @default(cuid())
  userId      String
  name        String
  description String?

  definition    String
  executionPlan String?
  creditsCost   Int     @default(0)

  cron String?

  status String // DRAFT | PUBLISHED

  lastRunAt     DateTime?
  lastRunId     String?
  lastRunStatus String?
  nextRunAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  executions WorkflowExecution[]

  // User cannot have two workflows with the same name
  @@unique([name, userId])
  @@index([userId, createdAt])
  @@index([userId, status])
}

model WorkflowExecution {
  id          String    @id @default(cuid())
  workflowId  String
  userId      String
  trigger     String
  status      String
  createdAt   DateTime  @default(now())
  startedAt   DateTime?
  completedAt DateTime?
  definition  String    @default("{}")

  creditsConsumed Int @default(0)

  phases ExecutionPhase[]

  workflow Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  @@index([userId, startedAt])
  @@index([workflowId])
}

model ExecutionPhase {
  id          String    @id @default(cuid())
  userId      String
  status      String
  number      Int
  node        String
  name        String
  startedAt   DateTime?
  completedAt DateTime?
  inputs      String?
  outputs     String?

  creditsConsumed Int?

  workflowExecutionId String
  execution           WorkflowExecution @relation(fields: [workflowExecutionId], references: [id], onDelete: Cascade)

  logs ExecutionLog[]

  @@index([userId, startedAt, status])
}

model ExecutionLog {
  id        String   @id @default(cuid())
  logLevel  String
  message   String
  timestamp DateTime @default(now())

  executionPhaseId String
  executionPhase   ExecutionPhase @relation(fields: [executionPhaseId], references: [id], onDelete: Cascade)
}

// Fixed naming: keep DB table as "UserBalanace" via map to avoid migration
model UserBalance {
  userId  String @id
  credits Int    @default(0)
}

model Credential {
  id     String @id @default(cuid())
  userId String
  name   String
  value  String

  createdAt DateTime @default(now())

  @@unique([userId, name])
}

model UserPurchase {
  id          String   @id @default(cuid())
  userId      String
  stripeId    String   @unique
  description String
  amount      Int
  currency    String
  date        DateTime @default(now())

  @@index([userId, date])
}

model ChatSession {
  id           String   @id @default(cuid())
  userId       String
  workflowId   String?  // Can be null for general chat not tied to a specific workflow
  messages     Json
  lastActiveAt DateTime @default(now())

  @@unique([userId, workflowId]) // Chat history is unique per user per workflow (or general if workflowId is null)
}

model UserProfileContext {
  id        String   @id @default(cuid())
  userId    String   @unique
  profileData Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model WorkflowData {
  id          String   @id @default(cuid())
  userId      String
  storageKey  String
  data        String   // Store as text to handle large data
  description String?
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, storageKey])
  @@index([userId, expiresAt]) // For efficient cleanup queries
}
